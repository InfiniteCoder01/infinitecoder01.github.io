<!DOCTYPE html><html><head><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/github-dark.min.css" rel="stylesheet"><script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/highlight.min.js"></script><link href="../../global.css" rel="stylesheet"><script>hljs.highlightAll();</script></head><body><h1 class="title">Writing a compiler backend for my programming language in ðŸ¦€</h1><div class = "warning" title="Heads up!"><h4>Heads up!</h4><p>Work in progress I sometimes stream the development <a href = "https://twitch.tv/infinitecoder01">here</a></p></div class = "warning"><div class = "note" title="Note"><h4>Note</h4><p>Yes, I don't like LLVM. I know, that cranelift exists, but I want to write my own. You can see the development <a href = "https://github.com/InfiniteCoder01/orecc-back">here</a></p></div class = "note"><div class = "warning" title="TODO"><h4>TODO</h4><p>Table of contents</p></div class = "warning"><p>This all started when I decided to make my own language. Again.<br>I wanted to make a rust-like language with an effect system and some more features. You can see it on <a href = "https://github.com/InfiniteCoder01/Trustlang">github</a>.<br>I've tried many approaches, but settled on tokenizing text â†’ parsing it into an AST â†’ building an Intermediate Representation (IR) from this AST â†’ converting this IR into raw bytes â†’ packaging those bytes into an application like ELF or PE.<br>The first problem I encountered with the backend itself is compiling to x86&#x005f;64. That's the first architecture I've tried to implement and already got stuck. Turns out that x86&#x005f;64 instruction set is really difficult (THIS IS ALL ABOUT BACKWARDS COMPATIBILITY!!!). It has some weird things like REX (register extensions) or some shortcuts (Why <code >add AL, 5</code> is taking 2 bytes (encoded as <code >04 05</code>) when <code >add BL, 5</code> takes 3 bytes (encoded as <code >80 c3 05</code>))<br>I've found this great page as reference for x86&#x005f;64 opcodes: <a href = "https://www-user.tu-chemnitz.de/~heha/hsn/chm/x86.chm/x64.htm">X86-64 Instruction Encoding</a> (<a href = "https://wiki.osdev.org/X86-64_Instruction_Encoding">OSDev Wiki</a> contains the same page) <a href = "https://shell-storm.org/x86doc/">This</a> table also helped me a lot.<br>When I did some first steps with x86&#x005f;64, I had to pack it into some sort of executable, which turned out a big challange. I couldn't find any rust crates that will write elf executables, only ones that write relocatibles and I want to integrate a linker into my backend. <a href = "https://www.youtube.com/watch?v=nC1U1LJQL8o&amp;list=WL&amp;index=6">This</a> video helped me A LOT with reading/writing elf files. But be aware: it has some wrong types! For example (the only one I found) sizes in program header. Check <a href = "https://en.wikipedia.org/wiki/Executable<em Linkable>and</em>Format">wiki</a> for that!<br>When I've implemented a minimal functionality for my elf crate, I've tried to compile a simple program and got segmentation fault. <a href = "https://www.youtube.com/watch?v=XH6jDiKxod8">This video</a> helped me finally figure it out. Essentially entry point has some strict rules. Finally, I released this crate: <a href = "https://crates.io/crates/orecc-elf">orecc-elf</a></p></body></html>